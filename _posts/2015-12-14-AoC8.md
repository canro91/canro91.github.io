---
layout: post
title: "Advent of Code Day 8: Connecting Junction Boxes"
tags: csharp
---

On [Day 8](https://adventofcode.com/2025/day/8) of Advent of Code, we're helping elves with some decorations, so we're connecting junction boxes.

Unlike the first 7 days, I cheated. Yes! This puzzle wasn't fun anymre after spending a couple of hours to make the example work. In a moment of frustration, I went to Reddit for some help and I reworked my original solution.

First, I tried to create circuits as I visited pair of junction boxes. But, after getting some help from Reddit, every junction box is a 1-box circuit to then merge all the pairs.

## Finding distances

To find the distance between all possibles pair of junction boxes, I borrowed the `Pairs()` method from [Day 3]({% post_url 2025-12-04-AoC3 %}).

To calculate the distance, I use the squared of the distance as a small optimization.

```csharp
var distances = allBoxes.Pairs()
    .Select(p => (p.First, p.Second, Distance: Distance(p.First, p.Second)))
    .OrderBy(p => p.Distance);

static int Distance(JunctionBox p1, JunctionBox p2)
{
    var d2 = (p1.X - p2.X) * (p1.X - p2.X)
                + (p1.Y - p2.Y) * (p1.Y - p2.Y)
                + (p1.Z - p2.Z) * (p1.Z - p2.Z);
    return d2;
}

static class Extensions
{
    public static IEnumerable<(T First, T Second)> Pairs<T>(this IEnumerable<T> self)
    {
        return self.SelectMany((fst, i) => self.Skip(i + 1).Select(snd => (fst, snd)));
    }
}
```

## Connecting boxes

A circuit is a wrapper around a `HashSet` with a method to merge two circuits.

```csharp
record Circuit(HashSet<JunctionBox> Boxes)
{
    public Circuit(JunctionBox box)
        : this(new HashSet<JunctionBox>([box]))
    {
    }

    public bool Contains(JunctionBox box)
        => Boxes.Contains(box);

    public void Connect(Circuit circuit)
    {
        foreach (var box in circuit.Boxes)
        {
            Boxes.Add(box);
        }
    }
}
```

With the list of junction boxes by distance and a circuit, here's the full solution,

```csharp
var allBoxes = new[]
{
    new JunctionBox(162,817,812),
    new JunctionBox(57,618,57),
    new JunctionBox(906,360,560),
    new JunctionBox(592,479,940),
    new JunctionBox(352,342,300),
    new JunctionBox(466,668,158),
    new JunctionBox(542,29,236),
    new JunctionBox(431,825,988),
    new JunctionBox(739,650,466),
    new JunctionBox(52,470,668),
    new JunctionBox(216,146,977),
    new JunctionBox(819,987,18),
    new JunctionBox(117,168,530),
    new JunctionBox(805,96,715),
    new JunctionBox(346,949,466),
    new JunctionBox(970,615,88),
    new JunctionBox(941,993,340),
    new JunctionBox(862,61,35),
    new JunctionBox(984,92,344),
    new JunctionBox(425,690,689),
};

var circuits = allBoxes.Select(box => new Circuit(box)).ToList();

var distances = allBoxes.Pairs()
    .Select(p => (p.First, p.Second, Distance: Distance(p.First, p.Second)))
    .OrderBy(p => p.Distance);
foreach (var pair in distances.Take(1_000))
{
    var hasFirstBox = circuits.First(c => c.Contains(pair.First));
    var hasSecondBox = circuits.First(c => c.Contains(pair.Second));
    if (hasFirstBox != hasSecondBox)
    {
        hasFirstBox.Connect(hasSecondBox);
        circuits.Remove(hasSecondBox);
    }
}

foreach (var circuit in circuits.OrderBy(c => c.Boxes.Count).Take(3))
{
    Console.WriteLine(circuit.Boxes.Count);
}
Console.ReadKey();

static int Distance(JunctionBox p1, JunctionBox p2)
{
    var d2 = (p1.X - p2.X) * (p1.X - p2.X)
                + (p1.Y - p2.Y) * (p1.Y - p2.Y)
                + (p1.Z - p2.Z) * (p1.Z - p2.Z);
    return d2;
}

record Circuit(HashSet<JunctionBox> Boxes)
{
    public Circuit(JunctionBox box)
        : this(new HashSet<JunctionBox>([box]))
    {
    }

    public bool Contains(JunctionBox box)
        => Boxes.Contains(box);

    public void Connect(Circuit circuit)
    {
        foreach (var box in circuit.Boxes)
        {
            Boxes.Add(box);
        }
    }
}
record JunctionBox(int X, int Y, int Z)
{
    public override string ToString() => $"{X},{Y},{Z}";
}

static class Extensions
{
    public static IEnumerable<(T First, T Second)> Pairs<T>(this IEnumerable<T> self)
    {
        return self.SelectMany((fst, i) => self.Skip(i + 1).Select(snd => (fst, snd)));
    }
}
```

Et voil√†!

Advent of Code sharpens your coding skills. But coding is more than typing symbols fast. It's also about teamwork, collaboration, and many skills I share in my book, _Street-Smart Coding: 30 Ways to Get Better at Coding._ That's the roadmap I wish I'd known from day one.

[Get your copy of Street-Smart Coding here](https://imcsarag.gumroad.com/l/streetsmartcoding/?utm_source=blog&utm_medium=post&utm_campaign=advent-2025-8)
